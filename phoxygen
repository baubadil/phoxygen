#!/usr/bin/env perl

#
# phoxygen -- Quick hack to produce doxygen-like documentation from PHP source code.
# This can do less than Doxygen, but one thing it does better is that it parses PHP
# function headers correctly and can document SQL CREATE TABLE statements.
#
# (C) 2015 Baubadil GmbH.
#
# phoxygen is free software; you can redistribute it and/or modify it under the terms of the GNU
# General Public License as published by the Free Software Foundation, in version 2 as it comes
# in the "LICENSE" file of the phoxygen main distribution. This program is distributed in the hope
# that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the LICENSE file for more details.
#

use strict;
use warnings;

###############################################################################################

my $g_progname = "phoxygen";

my $g_optVerbose = 0;
my $g_optNoWarnings = 0;
my $g_optDryRun = 0;
my $g_logDir;
my $clrError = 'bold red';
my $clrWarning = 'yellow';
my @g_llWarnings;

use Term::ANSIColor;
use Term::ANSIColor qw(:constants);
use Term::ANSIColor qw(colorvalid);
die "Error: no bright colors available, update perl-core/Term-ANSIColor!\nStopped"
    if (!colorvalid('bright_blue'));

###############################################################################################

my $fModeGiven;

#
# Processes command line options. Attempts to process one option with every call,
# but one call may remove more than one argument from $pllArgv.
#
# Returns 0 if no more arguments are left in $pllArgv, so call this in a while() loop.
# Otherwise, if the argument was understood and one or more arguments were processed,
# returns the reference $paOptionDefs (to be able to tell it from string values).
# Otherwise, if the argument was not understood, returns the argument as a string so
# that the caller can do custom processing.
#

sub myGetOpt
{
    my ($pllArgv,                # in/out: @ARGV (is shifted here)
        $paOptionDefs,           # in: hash with option definitions
        $paModes,                # in: hash of mode strings -> flags (optional)
        $pMode,                  # in/out: current mode (for when $paModes is specified)
        $pflMode                 # in/out: ORed mode flags (for when $paModes is specified)
       ) = @_;

    my $this;
    return 0
        if (!($this = shift(@ARGV)));

    funcEnter("myGetopt \"$this\"");

    my $rc = $this;
    my @llModes;
    if (    $paModes
         && $pMode
         && (@llModes = keys(%$paModes))
         && (isInList($this, \@llModes))
       )
    {
        myDie("duplicate mode argument \"$this\" (\"$$pMode\" already given)") if ($fModeGiven);
        $$pMode = $this;
        $rc = $paOptionDefs;
        $$pflMode = $paModes->{$this} if ($pflMode);
        $fModeGiven = 1;
    }
    elsif ($this =~ /^-/)
    {
        my %aShortOptions;
        my %aLongOptions;
        foreach my $opt (keys %$paOptionDefs)
        {
            if ((my $long, my $short) = ($opt =~ /(.*)\|(.*)/))
            {
                $aLongOptions{"--$long"} = $paOptionDefs->{$opt};
                $aShortOptions{"-$short"} = "--$long";
            }
            else
            {
                $aLongOptions{"--$opt"} = $paOptionDefs->{$opt};
            }
        }

        $this = $aShortOptions{$this} if ($aShortOptions{$this});

        if (my $v = $aLongOptions{$this})
        {
            $rc = $paOptionDefs;
            if (ref $v eq 'CODE')
            {
                $aLongOptions{$this}->($pllArgv);
            }
            else
            {
                myDie("invalid reference type in option defitions array for long option $this");
            }
        }
    }

    funcLeave("returning $rc");

    return $rc;
}

###############################################################################
#
# Printer/logger
#
###############################################################################

my @g_llFuncs;
our $g_fStillOnSameLineScreen;
my $g_fStillOnSameLineFile;
my $g_fLogFileOpened;

sub makePrintString
{
    my ($str,
        $fLog,                      # in: if 1, call is from myLog; if 0, call is from myPrint (non-verbose); if 2, verbose myPrint()
        $flNewline,                 # in: bitset, add 1 (bit 0) to suppress trailing newline;
                                    # add 2 (bit 1) to suppress automatic newline from previous call which has bit 0 set
                                    # to continue on the same line
        $pfStillOnSameLine          # in/out: reference to boolean
       ) = @_;

    my $str2; # = "{$$pfStillOnSameLine}";

    $flNewline = 0 if (!$flNewline);
    my $fForceFlush = (0 == ($flNewline & 0x02));

    if ($$pfStillOnSameLine && $fForceFlush)
    {
        $str2 = "\n";
    }

    # prefix progname if we're on a new line (because there was \n either in previous call or right above)
    if (    !$$pfStillOnSameLine
         || $fForceFlush
       )
    {
        if ($fLog == 1)
        {
            $str2 .= " $g_progname  ";
        }
        else
        {
            $str2 .= "[$g_progname] ";
        }

        if ($fLog)
        {
            # indent
            foreach my $func (@g_llFuncs)
            {
                $str2 .= "  ";
            }
        }
    }

    $str2 .= $str;

    $$pfStillOnSameLine = ($flNewline & 0x01);
    if (!$$pfStillOnSameLine)
    {
        $str2 .= "\n";
    }

    return $str2; # encode("utf-8", $str2);
}

sub printToLogFile
{
    my ($str,
        $fLog) = @_;

    if ($g_logDir)
    {
        if (!$g_fLogFileOpened)
        {
            my $fDir = 1;
            if (!(-d $g_logDir))
            {
                # can't use myMkdir here, that would recurse infinitely
                mkdir $g_logDir
                    or $fDir = 0;
                if (!$fDir)
                {
                    print "WARNING: [$g_progname] cannot mkdir \"$g_logDir\": $!. Logging is disabled!\n"
                        unless ($> == 0);           # do not complain if we're root (sudo something)
                    undef $g_logDir;
                }
            }
            if ($fDir)
            {
                my $file = "$g_logDir/".myTimeString(time, 1)."_$$.log";
                open(LOGFILE, "> $file")
                    or die "[$g_progname] Error: failed to open $file for writing: $!\nStopped";
                $g_fLogFileOpened = 1;
            }
        }

        print LOGFILE makePrintString($str,
                                      $fLog,
                                      0,
                                      \$g_fStillOnSameLineFile);
    }
}

#
# Custom print function, writes str to stdout.
# The program name, function indentation and trailing \n are automatically added.
#
# Mnemonic for flNewLine: use 0x01 on first call, use 0x02 on last call, use 0x03 for in-between
#
sub myPrint
{
    my ($str,
        $flNewline                  # in: bitset, add 1 (bit 0) to suppress trailing newline;
                                    # add 2 (bit 1) to suppress automatic newline from previous call which has bit 0 set
                                    # to continue on the same line
       ) = @_;

    my $fLog = ($g_optVerbose > 0) ? 2 : 0;        # fLog: if we're in verbose mode then pretend we're logging

    printToLogFile($str, $fLog);

    printAndFlush(makePrintString($str,
                                  $fLog,
                                  $flNewline,
                                  \$g_fStillOnSameLineScreen));
}

our $g_fSuppressLogging;

#
# Logger function, writes str to stdout if -v was specified on the command line.
# The program name, function indentation and trailing \n are automatically added.
#
sub myLog
{
    (my $str) = @_;

    if (!$g_fSuppressLogging)
    {
        printToLogFile($str, 1);

        if ($g_optVerbose > 0)
        {
            print makePrintString($str,
                                  1,
                                  0,
                                  \$g_fStillOnSameLineScreen)
        }
    }
}

sub funcEnter
{
    my ($func,
        $args
    ) = @_;

    myLog("Entering $func".(($args) ? " ($args)" : ''));
    push @g_llFuncs, $func;
}

sub funcLeave
{
    my ($args
    ) = @_;

    my $func = pop @g_llFuncs;
    myLog("Leaving $func".(($args) ? " ($args)" : ''));
}

#
# This is irreversible for the rest of the program's runtime!
#
sub closeLogFile
{
    if ($g_fLogFileOpened)
    {
        close LOGFILE;
        $g_fLogFileOpened = 0;
    }
}

sub printAndFlush
{
    my $string = shift;
    my $old_handle = select(STDOUT); # "select" STDOUT and save previously selected handle
    $| = 1; # perform flush after each write to STDOUT
    print $string;
    select($old_handle); # restore previously selected handle
}

sub myDie
{
    my ($msg) = @_;

    $msg =~ s|(.*)[ \n]*$|$1|;
    $msg .= '.' if (!($msg =~ /[.!?]$/));      # add full stop if not there yet
    if (length($msg) > 50)
    {
        $msg .= "\n"
    }
    else
    {
        $msg .= " ";
    }
    my ($package, $filename, $line) = caller;
    $msg = "[$g_progname] ".color($clrError)."Error: $msg".color('reset')."Caller: $filename, line $line."." Stopped";
    myLog("dying: $msg");
    main::cleanup();
    print "\n" if ($g_fStillOnSameLineScreen);
    die $msg;
}

sub clrError
{
    my ($msg) = @_;
    return colored($msg, $clrError);
}

sub clrWarning
{
    my ($msg) = @_;
    return colored($msg, $clrWarning);
}

sub myWarning
{
    my ($msg) = @_;
    push @g_llWarnings, $msg;
    myPrint(color($clrWarning)."WARNING: $msg".color('reset'))
        if (!$g_optNoWarnings);
}

###############################################################################################
#
# CLASSES
#
###############################################################################################

use Data::Dumper;

my %g_aClasses;                   # comment, type = class/interface, implements, extends
my %g_aPages;
my %g_aTables;
my %g_aRESTComments;
my $g_pMainPage;

use constant STATE_INIT                             => 0;
use constant STATE_IN_DOCCOMMENT                    => 1;
use constant STATE_IN_DOCCOMMENT_PAGE               => 2;
use constant STATE_IN_DOCCOMMENT_MAINPAGE           => 3;
use constant STATE_EXAMINE_NEXT_AFTER_DOCCOMMENT    => 4;
use constant STATE_IN_FUNCTION_HEADER               => 5;
use constant STATE_IN_CREATE_TABLE                  => 6;

{
    package DocComment;
    use Moose;

    use constant FLTYPE_PAGE                            => 0x01;
    use constant FLTYPE_MAINPAGE                        => 0x02 | FLTYPE_PAGE;
    use constant FLTYPE_CLASS                           => 0x04;
    use constant FLTYPE_FUNCTION                        => 0x08;
    use constant FLTYPE_TABLE                           => 0x10;
    use constant FLTYPE_REST                            => 0x20;

    has 'type'      => ( isa => 'Int', is => 'rw', init_arg => 0 );
    has 'keyword'   => ( isa => 'Str', is => 'ro' );
    has 'title'     => ( isa => 'Str', is => 'ro' );
    has 'comment'   => ( isa => 'Str', is => 'rw', default => '');
    has 'identifier'=> ( isa => 'Str', is => 'ro' );
    has 'file'      => ( isa => 'Str', is => 'ro' );
    has 'lines'     => ( isa => 'Str', is => 'ro' );

    sub append
    {
        my ($self, $line) = @_;
        $self->comment($self->comment.$line);
    }

    sub formatTitle
    {
        my ($self) = @_;
        return "Unknown";
    }

    sub formatComment
    {
        my ($self) = @_;

        my $htmlComment = '';
        my $fHadEmptyLine = 1;
        my $fPrependNewline = 1;

        use constant PARAGRAPH_INIT => 0;
        use constant PARAGRAPH_OPEN => 1;
        use constant PARAGRAPH_UL => 2;
        use constant PARAGRAPH_OL => 3;
        my $paraState = PARAGRAPH_INIT;

        foreach my $line (split(/\n/, $self->comment))
        {
            if ($line =~ /^\s*$/)
            {
                # Line consists entirely of whitespace, or is empty:
                $fHadEmptyLine = 1;
            }
            else
            {
                if ($fHadEmptyLine)
                {
                    if ($paraState == PARAGRAPH_OPEN)
                    {
                        $htmlComment .= "</p>\n\n";
                    }
                    elsif (    ($paraState == PARAGRAPH_UL)
                            || ($paraState == PARAGRAPH_OL)
                          )
                    {
                        $htmlComment .= "</li>";
                    }

                    if ($line =~ /^\s+(?:--?|\*)\s+/)
                    {
                        if ($paraState != PARAGRAPH_UL)
                        {
                            $htmlComment .= "<ul>";
                        }
                        else
                        {
                            $htmlComment .= "\n\n";
                        }

                        $htmlComment .= "<li>";
                        $paraState = PARAGRAPH_UL;

                        $line =~ s/^\s+(?:--?|\*)\s+/ /;
                    }
                    elsif ($line =~ /^\s+\d[.)]\s+/)
                    {
                        if ($paraState != PARAGRAPH_OL)
                        {
                            $htmlComment .= "<ol>";
                        }
                        else
                        {
                            $htmlComment .= "\n\n";
                        }

                        $htmlComment .= "<li>";
                        $paraState = PARAGRAPH_OL;

                        $line =~ s/^\s+\d[.)]\s+/ /;
                    }
                    else
                    {
                        if ($paraState == PARAGRAPH_UL)
                        {
                            $htmlComment .= "</ul>\n\n";
                        }
                        elsif ($paraState == PARAGRAPH_OL)
                        {
                            $htmlComment .= "</ol>\n\n";
                        }

                        $htmlComment .= "<p>";
                        $paraState = PARAGRAPH_OPEN;
                    }

                    $fPrependNewline = 0;
                    $fHadEmptyLine = 0;
                }

                $line =~ s/^\s+//;

                $htmlComment .= "\n"
                    if ($fPrependNewline);

                $htmlComment .= ::toHTML($line);

                $fPrependNewline = 1;
            }
        }

        if ($paraState == PARAGRAPH_OPEN)
        {
            $htmlComment .= "</p>";
        }
        elsif ($paraState == PARAGRAPH_UL)
        {
            $htmlComment .= "</ul>";
        }
        elsif ($paraState == PARAGRAPH_OL)
        {
            $htmlComment .= "</ol>";
        }

        foreach my $tag ( qw( ol /ol ul /ul li /li ) )
        {
            $htmlComment =~ s/&lt;$tag&gt;/<$tag>/g;
        }

        # Linkify all class names.
        foreach my $class (keys %g_aClasses)
        {
#             print ::Dumper($self);
            if (    ($self->type == FLTYPE_CLASS)
                 && ($self->identifier eq $class)
               )
            {
                $htmlComment =~ s/(^|p>|\s+)$class($|\s|[.,!;])/$1<b>$class<\/b>$2/g;
            }
            else
            {
                $htmlComment =~ s/(^|p>|\s+)$class($|\s|[.,!;])/$1<a href=\"class_$class.html\">$class<\/a>$2/g;
            }
        }

        # Resolve \refs to functions.
        $htmlComment =~ s/\\ref\s+([a-zA-Z_0-9]+::[a-zA-Z_0-9]+\(\))/resolveFunctionRef($1)/eg;

        # Resolve \refs to page IDs.
        $htmlComment =~ s/\\ref\s+([a-zA-Z_0-9]+)/resolvePlainRef($1)/eg;

        return $htmlComment;
    }

    sub resolveFunctionRef
    {
        my ($id) = @_;

        my ($class, $function) = $id =~ /([a-zA-Z_0-9]+)::([a-zA-Z_0-9]+)\(\)/;

        if (my $pClass = $g_aClasses{$class})
        {
            my $paMembers = $pClass->paMembers;
            if (my $pFunction = $paMembers->{$function})
            {
                return "<a href=\"class_$class.html#$function\">$id</a>";
            }
            else
            {
                ::myWarning("Invalid function name $function in reference $id");
            }

        }
        else
        {
            ::myWarning("Invalid class name $class in reference $id");
        }

        return $class.$function;
    }

    sub resolvePlainRef
    {
        my ($id) = @_;
        if (my $p = $g_aPages{$id})
        {
            my $title = ::toHTML($p->title);
            return "<a href=\"page_$id.html\">$title</a>";
        }
        elsif ($p = $g_aTables{$id})
        {
            return "<a href=\"table_$id.html\">$id</a>";
        }
        ::myWarning("Invalid reference: page ID $id not found");
        return $id;
    }
}

{
    package PageComment;
    use Moose;
    extends 'DocComment';

    sub BUILD
    {
        my ($self) = @_;
        $self->type(DocComment::FLTYPE_PAGE);
    }

    sub formatTitle
    {
        my ($self) = @_;
        return $self->title;
    }
}

{
    package MainPageComment;
    use Moose;
    extends 'PageComment';

    sub BUILD
    {
        my ($self) = @_;
        $self->type(DocComment::FLTYPE_MAINPAGE);
    }
}

{
    package RESTComment;
    use Moose;
    extends 'DocComment';

    has 'method'    => ( isa => 'Str', is => 'rw' );
    has 'name'      => ( isa => 'Str', is => 'rw' );

    sub BUILD
    {
        my ($self) = @_;
        $self->type(DocComment::FLTYPE_REST);
    }

    sub formatTitle
    {
        my ($self) = @_;
        return "REST API <code>".$self->identifier."</code>";
    }
}

{
    package TableComment;
    use Moose;
    extends 'DocComment';

    has 'definition'    => ( isa => 'ArrayRef[Str]', is => 'rw' );

    sub BUILD
    {
        my ($self) = @_;
        $self->type(DocComment::FLTYPE_TABLE);
        $self->definition([]);
    }

    sub formatTitle
    {
        my ($self) = @_;
        return "Table <code>".$self->identifier."</code>";
    }

    sub processInputLine
    {
        my ($self, $line, $pState) = @_;

#         ::myLog("tabledef line: $line");

        my $pll = $self->definition;
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;
        push @$pll, $line;

        if ($line =~ /^\s*(?:EOD|\))/)
        {
            $$pState = ::STATE_INIT;
        }
    }

    sub formatComment
    {
        my ($self) = @_;

        my $html = $self->SUPER::formatComment();

#         print ::Dumper($self->definition);
        my $pll = $self->definition;
        my $c = 0;
        if (my $cLines = scalar(@$pll))
        {
            $html .= "\n<pre>\n";
            foreach my $line (@$pll)
            {
                ++$c;
                $html .= '    ';
                $html .= '    '
                    if ( ($c > 1) && ($c < $cLines) );
                my $htmlLine = ::toHTML($line);

                foreach my $table (keys %g_aTables)
                {
                    $htmlLine =~ s/REFERENCES\s($table)\(/<a href="table_$1.html">$1<\/a>(/;
                }

                $html .= "$htmlLine\n";
            }
            $html .= "\n</pre>\n";
        }

        return $html;
    }
}

{
    package ClassComment;
    use Moose;
    extends 'DocComment';

    has 'pllMembers'        => ( isa => 'ArrayRef[FunctionComment]', is => 'rw' );
    has 'paMembers'          => ( isa => 'HashRef[FunctionComment]', is => 'rw' );
    has 'parents'           => ( isa => 'ArrayRef[String]', is => 'rw' );
    has 'children'          => ( isa => 'ArrayRef[ClassComment]', is => 'rw' );
    has '_implements'       => ( isa => 'Str', is => 'rw' );
    has '_extends'          => ( isa => 'Str', is => 'rw' );

    sub BUILD
    {
        my ($self) = @_;
        $self->pllMembers([]);
        $self->paMembers({});
        $self->parents([]);
        $self->children([]);
        $self->type(DocComment::FLTYPE_CLASS);
    }

    sub formatTitle
    {
        my ($self) = @_;
        return "Class ".$self->identifier;
    }

    sub addMember
    {
        my ($self, $pNewMember) = @_;
        my $pllMembers = $self->pllMembers;
        push @$pllMembers, $pNewMember;
        my $paMembers = $self->paMembers;
        $paMembers->{$pNewMember->identifier} = $pNewMember;

#         ::myLog("        added member ".$newMember->identifier." to class ".$self->identifier);
    }

    sub addParent
    {
        my ($self, $newParent) = @_;
        my $pllParents = $self->parents;
        push @$pllParents, $newParent;
#         ::myLog("        added member ".$newMember->identifier." to class ".$self->identifier);
    }

    sub addChild
    {
        my ($self, $newChild) = @_;
        my $pllChildren = $self->children;
        push @$pllChildren, $newChild;
#         ::myLog("        added member ".$newMember->identifier." to class ".$self->identifier);
    }

    sub formatChildrenList
    {
        my ($self) = @_;

        my $htmlBody = '';

        my $pllChildren = $self->children;
        if (my $cChildren = scalar(@$pllChildren))
        {
            $htmlBody .= "<ul>";
            foreach my $pChild (@$pllChildren)
            {
                my $child = $pChild->identifier;
                $htmlBody .= "<li><a href=\"class_$child.html\">$child</a>";

                $htmlBody .= $pChild->formatChildrenList();

                $htmlBody .= "</li>\n";
            }
            $htmlBody .= "</ul>";
        }

        return $htmlBody;
    }
}

{
    package FunctionComment;
    use Moose;
    extends 'ClassComment';

    has 'class'     => ( isa => 'ClassComment', is => 'rw' );        # parent class, if any
    has 'params'    => ( isa => 'ArrayRef[Str]', is => 'rw' );

    sub BUILD
    {
        my ($self) = @_;
        $self->params([]);
        $self->type(DocComment::FLTYPE_FUNCTION);
    }

    sub processInputLine
    {
        my ($self, $line, $pState) = @_;

        # ::myLog("function line: $line");
        if ( (my $param, my $sep, my $descr) = $line =~ /^\s*([&\$A-Za-z0-9_ ='"-]+)\s*([,;)])\s*(?:\/\/!<\s*(.*))?$/)
        {
            my $oldstate = $$pState;
            $$pState = ($sep eq ',')
                            ? ::STATE_IN_FUNCTION_HEADER
                            : ::STATE_INIT;
            $descr = '' if (!$descr);
            ::myLog("  after function: param=$param, sep='$sep', descr=$descr, state=$oldstate->".$$pState);

            my $pll = $self->params;
            push @$pll, [ $param, $descr ];
        }
        elsif ( (my $args) = $line =~ /(.*)\)/)
        {
            my @llArgs;
            foreach my $arg (split(/,/, $args))
            {
                $arg =~ s/^\s+//;
                $arg =~ s/\s+$//;
                push @llArgs, [ $arg, '' ];
            }
            ::myLog("after function 1+ args: \"".join('\", \"', @llArgs).'"');
            $$pState = ::STATE_INIT;
            my $pll = $self->params;
            push @$pll, @llArgs;
        }
        else
        {
            my $inputFile = $self->file;
            my $lines = $self->lines;
            ::myWarning("don't know how to handle function header in $inputFile (lines $lines)");
        }
    }

    sub formatFunction
    {
        my ($self, $fLong) = @_;

        my $htmlBody = '';

        my $pllArgs = $self->params;
        my $cTotal = scalar(@$pllArgs);

        #    Build a table like this:
        #    +----------------------+------------------------+---------------------+
        #    |   funcname(          | arg1,                  | comment1            |
        #    |                      | arg2,                  | comment2            |
        #    |                      | arg3)                  | comment3            |
        #    +----------------------+------------------------+---------------------+

        if (!$cTotal)
        {
            $htmlBody .= $self->keyword." <b>".$self->identifier."</b>()";
        }
        else
        {
            $htmlBody .= "<table class=\"functable\"><tr><td>"
                if ($fLong);
            $htmlBody .= $self->keyword." <b>".$self->identifier."</b>(";
            $htmlBody .= "</td>"
                if ($fLong);

            my $c = 0;
            foreach my $pllParam (@$pllArgs)
            {
                ++$c;
                if ($fLong)
                {
                    $htmlBody .= "<tr><td>&nbsp;</td>"
                        if ($c > 1);
                    $htmlBody .= "<td>";
                }
                my @llParams2 = @$pllParam;
                my $param = shift(@llParams2);
                my $descr = shift(@llParams2);
                $htmlBody .= $param;
                $htmlBody .= ($c == $cTotal) ? ') ' : ', ';
                if ($fLong)
                {
                    $htmlBody .= "</td>\n<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>".::toHTML($descr);
                    $htmlBody .= "</i></td></tr>";
                }
            }
            $htmlBody .= "</table>"
                if ($fLong);
        }

        return $htmlBody;
    }
}

###############################################################################################
#
# MAIN CODE -- PARSER
#
###############################################################################################

my %g_aOptionDefs = (
                      'verbose|v'           => sub {++$g_optVerbose;},
                    );

my @llInputFiles;

while (my $this = myGetOpt(\@ARGV, \%g_aOptionDefs, undef, undef, undef))
{
    next if ($this eq \%g_aOptionDefs);
    if ($this =~ /^-/)
    {
        myDie("don't understand option argument '$this'");
    }
    elsif (-f $this)
    {
        push @llInputFiles, $this;
    }
    else
    {
        myDie("don't know what to do with argument '$this'");
    }
}

if (!@llInputFiles)
{
    my $cmd = 'find . -name "*.php"';
    open(FIND, "$cmd |")
        or myDie("failed to run \"$cmd\": $!");
    while (<FIND>)
    {
        chomp;
        next if /\/3rdparty\//;
        push @llInputFiles, $_;
    }
    close FIND;
}

#
# PARSE INPUT FILES
#

my $cFiles = scalar @llInputFiles;
my $c = 0;
foreach my $inputFile (@llInputFiles)
{
    ++$c;
    myPrint("Processing $c/$cFiles: $inputFile...");
    open(INPUT, $inputFile)
        or myDie("failed to open file $inputFile for reading: $!");

    my $lineno = 0;
    my $state = STATE_INIT;                  # STATE_* constant
    my $cLinesExamined = 0;

    my $strCurrentComment = '';
    my $linenoWhereCommentBegan;
    my $linenoWhereCommentEnded = 0;
    my $pLastFunction;
    my $pLastTable;
    my $pCurrentClass;
    my $pCurrent;                         # Current object. In the event of a \page, this gets set BEFORE the doccomment closes.
                                        # In the event of a class or function or the like, this gets set AFTER the doccomment closes.
    funcEnter("file $inputFile");
    while (<INPUT>)
    {
        ++$lineno;

        if (/^\s*\/\*\*/)
        {
            #
            # OPENING DOCCOMMENT
            #
            # Ignore them if they have many asterisks.
            next if (/^\s*\/\*\*\*\*\*\*\*/);
            # Begin doxygen comment:
            $state = STATE_IN_DOCCOMMENT;
            $strCurrentComment = '';
            $linenoWhereCommentBegan = $lineno;
            myLog("Found opening comment on line $lineno, state=$state")
                if ($g_optVerbose > 1)
        }
        elsif (    ($state == STATE_IN_DOCCOMMENT)
                || ($state == STATE_IN_DOCCOMMENT_PAGE)
                || ($state == STATE_IN_DOCCOMMENT_MAINPAGE)
              )
        {
            if (/\*\//)
            {
                #
                # CLOSING DOCCOMMENT
                #
                my $oldstate = $state;
                if (    ($state == STATE_IN_DOCCOMMENT_PAGE)
                     || ($state == STATE_IN_DOCCOMMENT_MAINPAGE)
                   )
                {
                    $state = STATE_INIT;
                    $pCurrent->append($strCurrentComment);
                }
                else
                {
                    $state = STATE_EXAMINE_NEXT_AFTER_DOCCOMMENT;
                    $cLinesExamined = 0;
                }
                myLog("Found closing comment on line $lineno, state=$oldstate->$state")
                    if ($g_optVerbose > 1);
                $linenoWhereCommentEnded = $lineno;
            }
            else
            {
                my $line = $_;
                $line =~ s/^\s+\* ?//;

                if (/\\mainpage/)
                {
                    my ($pageTitle) = /\\mainpage\s+(.*)/;

                    $state = STATE_IN_DOCCOMMENT_MAINPAGE;
                    myLog("line $linenoWhereCommentBegan: found \\mainpage (state=$state)");
                    $pCurrent = MainPageComment->new(   title   => $pageTitle,
                                                        file    => $inputFile,
                                                        lines   => "$linenoWhereCommentBegan--$linenoWhereCommentEnded"
                                                    );
                    $g_pMainPage = $pCurrent;
                }
                elsif (/\\page/)
                {
                    my ($pageID, $pageTitle) = /\\page\s+([a-zA-Z0-9_-]+)\s+(.*)/;

                    if (!$pageTitle)
                    {
                        myDie("Incomplete \\page in comment beginning at line $lineno");
                    }

                    $state = STATE_IN_DOCCOMMENT_PAGE;
                    myLog("line $linenoWhereCommentBegan: found \\page $pageID with title \"$pageTitle\" (state=$state)");

                    $pCurrent = PageComment->new(   identifier  => $pageID,
                                                    title       => $pageTitle,
                                                    file        => $inputFile,
                                                    lines       => "$linenoWhereCommentBegan--$linenoWhereCommentEnded"
                                                );
                    $g_aPages{$pageID} = $pCurrent;
                }
                else
                {
                    $strCurrentComment .= $line;
                    myLog("Added line: $line")
                        if ($g_optVerbose > 2);
                }
            }
        }
        elsif (/^\s*$/)     # Outside comments, ignore empty lines.
        {
            next;
        }
        elsif ($state == STATE_EXAMINE_NEXT_AFTER_DOCCOMMENT)
        {
            # First non-empty line after non-page comment:
            my $keyword;
            my $identifier;
            if (    ( ($keyword, $identifier) = /^\s*((?:abstract\s+)?class)\s+(\S+)/ )
                 || ( ($keyword, $identifier) = /^\s*(interface)\s+(\S+)/ )
               )
            {
                #
                # STORE CLASS
                #
                funcEnter("line $linenoWhereCommentBegan: found $keyword $identifier");

                $pCurrent = ClassComment->new(  keyword     => $keyword,
                                                identifier  => $identifier,
                                                comment     => $strCurrentComment,
                                                file        => $inputFile,
                                                lines       => "$linenoWhereCommentBegan--$linenoWhereCommentEnded"
                                           );
                my @llParents;
                if ( (my $implements) = /^\s*class\s+\S+\s+implements\s+(\S+)/ )
                {
                    $pCurrent->_implements($implements);
                    push @llParents, split(/\s*,\s*/, $implements);
                }
                if ( (my $extends) = /^\s*(?:abstract\s+)?(?:class|interface)\s+\S+\s+extends\s+(\S+)$/ )
                {
                    $pCurrent->_extends($extends);
                    push @llParents, split(/\s*,\s*/, $extends);
                }

                my @ll;
                foreach my $parent (@llParents)
                {
                    $pCurrent->addParent($parent);
                }

                $g_aClasses{$identifier} = $pCurrent;
                $pCurrentClass = $pCurrent;
                $state = STATE_INIT;

                # my $exts = ($pCurrent->extends) ? ', extends "'.$pCurrent->extends.'"' : '';
                # my $impl = ($pCurrent->implements) ? ', implements "'.$pCurrent->implements.'"' : '';
                funcLeave();
            }
            elsif ( ($identifier, my $afterOpeningBracket) = /(?:^|\s+)function\s+([A-Za-z0-9_]+)\s*\((.*)/ )
            {
                #
                # STORE FUNCTION
                #
                myLog("line $linenoWhereCommentBegan: found function $identifier, afterOpeningBracket=$afterOpeningBracket");

                ($keyword) = /^\s*(.*function)/;

                $pCurrent = FunctionComment->new(   identifier  => $identifier,
                                                    keyword     => $keyword,
                                                    comment     => $strCurrentComment,
                                                    file        => $inputFile,
                                                    lines       => "$linenoWhereCommentBegan--$linenoWhereCommentEnded"
                                                );
                $pLastFunction = $pCurrent;

                if (defined($pCurrentClass))
                {
                    # Member function: two-way linking.
                    $pLastFunction->class($pCurrentClass);
                    $pCurrentClass->addMember($pLastFunction);
                }

                $pLastFunction->processInputLine($afterOpeningBracket, \$state);
            }
            elsif ( my ($identifier) = /^\s*CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?([A-Za-z_]+)/ )
            {
                #
                # STORE TABLE
                #
                myLog("line $linenoWhereCommentBegan: found table $identifier");

                $pCurrent = TableComment->new(      identifier  => $identifier,
                                                    comment     => $strCurrentComment,
                                                    file        => $inputFile,
                                                    lines       => "$linenoWhereCommentBegan--$linenoWhereCommentEnded"
                                                );
                $g_aTables{$identifier} = $pCurrent;
                $pLastTable = $pCurrent;
                $state = STATE_IN_CREATE_TABLE;

                $pLastTable->processInputLine($_, \$state);
            }
            elsif ( my ($method, $nameAndArgs) = /^\s*\S+->(get|post)\(["'"](.*)["'"],/ )
            {
                #
                # STORE REST API
                #
                my ($name, $args) = ($nameAndArgs =~ /\/([^\/]+)(\/.*)?/);
                my $identifier = $method.'_'.$name;
                myLog("line $linenoWhereCommentBegan: found REST API $method, $name => $identifier");

                $pCurrent = RESTComment->new(      method      => uc($method),
                                                   name        => $name,
                                                   identifier  => $identifier,
                                                   args        => $args,
                                                   comment     => $strCurrentComment,
                                                   file        => $inputFile,
                                                   lines       => "$linenoWhereCommentBegan--$linenoWhereCommentEnded"
                                                );
                $g_aRESTComments{$identifier} = $pCurrent;
                $state = STATE_INIT;

                # $pLastTable->processInputLine($_, \$state);
            }
            elsif ($cLinesExamined < 2)
            {
                ++$cLinesExamined;
            }
            else
            {
                myWarning("don't know what to do with comment in $inputFile (lines $linenoWhereCommentBegan--$linenoWhereCommentEnded)");
                $state = STATE_INIT;
            }
        }
        elsif ($state == STATE_IN_FUNCTION_HEADER)
        {
            # Continuing function header:
            $pLastFunction->processInputLine($_, \$state);
        }
        elsif ($state == STATE_IN_CREATE_TABLE)
        {
            $pLastTable->processInputLine($_, \$state);
        }
    }
    funcLeave();

    myPrint("Done, $lineno lines.");
    close(INPUT);
}

# Create pseudo entries for PHP classes that we derive from. TODO do this in the code files
foreach my $identifier (qw( XMLReader Exception ))
{
    my $pCurrent = new ClassComment ( keyword     => 'class',
                                      identifier  => $identifier,
                                      comment     => "Default PHP class.",
                                    );
    $g_aClasses{$identifier} = $pCurrent;
}


###############################################################################################
#
# MAIN CODE -- WRITE OUTPUT FILES
#
###############################################################################################

my $dirHTMLOut = 'doc/html';
my $dirLatexOut = 'doc/latex';
`mkdir -p $dirHTMLOut`;
`mkdir -p $dirLatexOut`;

if (!$g_pMainPage)
{
    $g_pMainPage = new MainPageComment( comment => 'You need to write a \\mainpage article.',
                                        title => 'Main page' );
}

my $htmlTitle = $g_pMainPage->formatTitle();
my $g_title = html2Latex($htmlTitle);

my $fullfile = "$dirLatexOut/index.tex";
open(LATEX, "> $fullfile")
    or myDie("cannot open $fullfile for writing: $!");
print LATEX '
\documentclass[oneside,a4paper,10pt,DIV10]{scrbook}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[pdftex,
            a4paper,
            bookmarksnumbered,
            bookmarksopen=true,
            bookmarksopenlevel=0,
            colorlinks=true,
            hyperfootnotes=false,
            linkcolor=blue,
            plainpages=false,
            pdfpagelabels,
            urlcolor=darkgreen
  ]{hyperref}
\usepackage{underscore}

% Fonts
% \usepackage{gentium}
% \usepackage{libertine}
\usepackage{paratype}
\usepackage{helvet}
\usepackage[scaled]{beramono}

% \renewcommand*\familydefault{\ttdefault}

\newcommand\mytitle{'.$g_title.'}

\title{\mytitle}
\hypersetup{pdftitle=\mytitle}

\begin{document}
\maketitle
\tableofcontents

';

funcEnter("writing main page");

bless($g_pMainPage, 'MainPageComment');
my $html = "<h1>$htmlTitle</h1>\n";
my $htmlThis = $g_pMainPage->formatComment();
$html .= $htmlThis;
writeHTML($dirHTMLOut,
          'index.html',
          $htmlTitle,
          $html);

print LATEX "\n\\chapter{".html2Latex($htmlTitle)."}\n";
print LATEX "\n".html2Latex($htmlThis)."\n";

funcLeave();

#
# Page files.
#

funcEnter("writing other pages");

$htmlTitle = "Pages list";
my $htmlBody = "<h1>$htmlTitle</h1>\n\n<ul>";

foreach my $pageID (sort keys %g_aPages)
{
    my $pPage = $g_aPages{$pageID};
    my $title = toHTML($pPage->title);
    $htmlBody .= "<li><a href=\"page_$pageID.html\">$title</a>";
}

$htmlBody .= "</ul>\n";

writeHTML($dirHTMLOut,
          "index_pages.html",
          $htmlTitle,
          $htmlBody);

print LATEX "\n\\chapter{Pages}\n";

foreach my $pageID (sort keys %g_aPages)
{
    my $pPage = $g_aPages{$pageID};
    my $htmlTitle = toHTML($pPage->title);
    my $htmlBody = "<h1>$htmlTitle</h1>\n";

    $htmlThis = $pPage->formatComment();
    $htmlBody .= $htmlThis;

    writeHTML($dirHTMLOut,
              "page_$pageID.html",
              $htmlTitle,
              $htmlBody);

    print LATEX "\n\\section{".html2Latex($htmlTitle)."}\n";
    print LATEX "\n".html2Latex($htmlThis)."\n";
}

funcLeave();


#
# REST API files.
#

funcEnter("writing REST APIs");

$htmlTitle = "REST APIs list";
$htmlBody = "<h1>$htmlTitle</h1>\n\n<ul>";

foreach my $restapi (sort keys %g_aRESTComments)
{
    my $pREST = $g_aRESTComments{$restapi};
    $htmlBody .= "<li><a href=\"rest_$restapi.html\">".$pREST->method.' '.$pREST->name."</a>";
}

$htmlBody .= "</ul>\n";

writeHTML($dirHTMLOut,
          "index_restapis.html",
          $htmlTitle,
          $htmlBody);

print LATEX "\n\\chapter{REST APIs}\n";

foreach my $restapi (sort keys %g_aRESTComments)
{
    my $pREST = $g_aRESTComments{$restapi};

    my $htmlTitle = $pREST->formatTitle();
    my $htmlBody = "<h1>$htmlTitle</h1>\n";

    $htmlThis = $pREST->formatComment();
    $htmlBody .= $htmlThis;

    writeHTML($dirHTMLOut,
              "rest_$restapi.html",
              $htmlTitle,
              $htmlBody);

    print LATEX "\n\\section{".html2Latex($htmlTitle)."}\n";
    print LATEX "\n".html2Latex($htmlThis)."\n";
}

funcLeave();


#
# Table files.
#

funcEnter("writing tables");

$htmlTitle = "Tables list";
$htmlBody = "<h1>$htmlTitle</h1>\n\n<ul>";

foreach my $table (sort keys %g_aTables)
{
    my $pTable = $g_aTables{$table};
    $htmlBody .= "<li><a href=\"table_$table.html\">$table</a>";
}

$htmlBody .= "</ul>\n";

writeHTML($dirHTMLOut,
          "index_tables.html",
          $htmlTitle,
          $htmlBody);

print LATEX "\n\\chapter{Tables}\n";

foreach my $table (sort keys %g_aTables)
{
    my $pTable = $g_aTables{$table};

    my $htmlTitle = $pTable->formatTitle();
    my $htmlBody = "<h1>$htmlTitle</h1>\n";

    $htmlThis = $pTable->formatComment();
    $htmlBody .= $htmlThis;

    writeHTML($dirHTMLOut,
              "table_$table.html",
              $htmlTitle,
              $htmlBody);

    print LATEX "\n\\section{".html2Latex($htmlTitle)."}\n";
    print LATEX "\n".html2Latex($htmlThis)."\n";
}

funcLeave();

#
# Class files.
#

funcEnter("Writing class list");

$htmlTitle = "Class list";
$htmlBody = "<h1>$htmlTitle</h1>\n\n";
$htmlThis = '<ul>';

# Resolve children.
foreach my $class (sort keys %g_aClasses)
{
    my $pClass = $g_aClasses{$class};
    my $pllParents = $pClass->parents;
    foreach my $parent (@$pllParents)
    {
        if (exists($g_aClasses{$parent}))
        {
            my $pParent = $g_aClasses{$parent};
            $pParent->addChild($pClass);
            myLog("adding child $class to parent $parent");
        }
        else
        {
            myWarning("Class $class specifies parent class \"$parent\" but that cannot be found.");
        }
    }
}

# Loop through all classes which have NO PARENT and list children thereunder.
foreach my $class (sort keys %g_aClasses)
{
    funcEnter("testing class $class");
    my $pClass = $g_aClasses{$class};
    my $pllParents = $pClass->parents;
    my $cParents = scalar @$pllParents;
    myLog("$cParents parents");
    if (!$cParents)
    {
        $htmlThis .= "<li><a href=\"class_$class.html\">$class</a>";

        $htmlThis .= $pClass->formatChildrenList();

        $htmlThis .= "</li>\n";
    }
    funcLeave();
}

$htmlThis .= "</ul>";

$htmlBody .= $htmlThis;
writeHTML($dirHTMLOut,
          "index_classes.html",
          $htmlTitle,
          $htmlBody);

print LATEX "\n\\chapter{Class list}\n";
print LATEX "\n".html2Latex($htmlThis)."\n";

funcLeave();

#
# One HTML file per class.
#

funcEnter("Writing class files");

foreach my $class (keys %g_aClasses)
{
    my $pClass = $g_aClasses{$class};

    my $htmlTitle = $pClass->formatTitle();
    my $htmlBody = "<h1>$htmlTitle</h1>\n";

    $htmlThis = $pClass->formatComment();
    $htmlBody .= $htmlThis;

    print LATEX "\n\\section{".html2Latex($htmlTitle)."}\\label{class-$class}\n";
    print LATEX "\n".html2Latex($htmlThis)."\n";

    $htmlBody .= "<h2>Hierarchy</h2>\n\n";
    $htmlThis = '';
    my $pllParents = $pClass->parents;
    my $pllChildren = $pClass->children;
    if (scalar @$pllParents)
    {
        foreach my $parent (@$pllParents)
        {
            $htmlThis .= "<a href=\"class_$parent.html\">$parent</a> &mdash; ";
        }
    }

    if (    (scalar @$pllParents)
         || (scalar @$pllChildren)
       )
    {
        $htmlThis .= "<b>$class</b>";
    }
    else
    {
        $htmlThis .= "<p>This class stands alone and has neither parents nor children.</p>";
    }

    if (scalar @$pllChildren)
    {
        $htmlThis .= ' &mdash; ';
        my $c = 0;
        foreach my $pChild (@$pllChildren)
        {
            $htmlThis .= ", " if ($c);
            my $child = $pChild->identifier;
            $htmlThis .= "<a href=\"class_$child.html\">$child</a>";
            ++$c;
        }
    }

    $htmlBody .= $htmlThis;

    print LATEX "\n\\subsection{Hierarchy}\n";
    print LATEX "\n".html2Latex($htmlThis)."\n";

    my $pllMembers = $pClass->pllMembers;
    my $cMembers = scalar(@$pllMembers);
    myLog("Class $class has $cMembers members");
    if ($cMembers)
    {
        $htmlBody .= "<h2>$cMembers members</h2>\n\n";

        print LATEX "\n\\subsection{Members}\n";

        $htmlThis = "<ul>\n";
        foreach my $pMemberFunction (@$pllMembers)
        {
            my $identifier = $pMemberFunction->identifier;
            $htmlThis .= "<li><a href=\"#$identifier\">";
            $htmlThis .= $pMemberFunction->formatFunction(0); # short
            $htmlThis .= "</a></li>";
            $htmlThis .= "\n";
        }
        $htmlThis .= "</ul>\n";

        $htmlBody .= $htmlThis;

        $htmlBody .= "\n<h2>Details</h2>\n";
        $htmlThis = '';

        foreach my $pMemberFunction (@$pllMembers)
        {
            my $identifier = $pMemberFunction->identifier;
            $htmlThis .= "<dl><dt id=\"$identifier\">";
            $htmlThis .= $pMemberFunction->formatFunction(1)."</dt>\n";
            my $htmlDesc = $pMemberFunction->formatComment();
            $htmlThis .= "<dd>".$htmlDesc."</dd></dl>";
            $htmlThis .= "\n";

            print LATEX "\n\\subsubsection{".html2Latex($pMemberFunction->formatFunction(0))."}\n";
            print LATEX "\n".html2Latex($htmlDesc)."\n";
        }

        $htmlBody .= $htmlThis;
    }

    writeHTML($dirHTMLOut,
              "class_$class.html",
              $htmlTitle,
              $htmlBody);
}

funcLeave();

print LATEX '
\end{document}
';

close LATEX;

exit 0;

###############################################################################################
#
# SUBS
#
###############################################################################################

sub toHTML
{
    my ($str) = @_;
    $str =~ s/&/&amp;/g;
    $str =~ s/</&lt;/g;
    $str =~ s/>/&gt;/g;
    return $str;
}

sub html2Latex
{
    my ($str) = @_;
#     $str =~ s/&/&amp;/g;
#     $str =~ s/</&lt;/g;
#     $str =~ s/>/&gt;/g;

    $str =~ s/<\/?p>//g;

    $str =~ s/<ul>/\\begin{itemize}\n/g    ;
    $str =~ s/<\/ul>/\n\\end{itemize}/g;
    $str =~ s/<ol>/\\begin{enumerate}\n/g;
    $str =~ s/<\/ol>/\n\\end{enumerate}/g;
    $str =~ s/<li>/\\item /g;
    $str =~ s/<\/li>//g;

    $str =~ s/<pre>/\\begin{verbatim}/g    ;
    $str =~ s/<\/pre>/\\end{verbatim}/g;

    $str =~ s/<code>/\\texttt{/g;
    $str =~ s/<\/code>/}/g;
    $str =~ s/<b>/\\textbf{/g;
    $str =~ s/<\/b>/}/g;

    $str =~ s/<a href="class_([^"]+)\.html">[^<]+<\/a>/\\hyperref[class-$1]{$1}/g;
#               <a href="class_Access.html">Access</a>
    $str =~ s/<a [^>]+>//g;
    $str =~ s/<\/a>//g;
#     $str =~ s/_/{\\_}/g;

    $str =~ s/&mdash;/--/g;
    $str =~ s/&nbsp;/~/g;
    $str =~ s/&lt;/</g;
    $str =~ s/&gt;/>/g;
    $str =~ s/&amp;/&/g;
    $str =~ s/\$/\\\$/g;
    $str =~ s/#/\\#/g;
    $str =~ s/&/\\&/g;

    return $str;
}

sub writeHTML
{
    my ($dirHTMLOut,
        $fname,
        $title,
        $htmlBody
       ) = @_;

    my $fullfile = "$dirHTMLOut/$fname";
    open(HTML, "> $fullfile")
        or myDie("cannot open $fullfile for writing: $!");
    print HTML <<"EOD";
<html>
<head>
  <title>$title &mdash; Doreen documentation</title>
  <style>
.functable
{
    display: inline;
    border-collapse: collapse;
    vertical-align: top;
}
.functable td
{
    vertical-align: top;
}
  </style>
</head>
<body>
<a href="index.html">Home</a> &mdash; 
<a href="index_pages.html">Topics</a> &mdash; 
<a href="index_restapis.html">REST APIs</a> &mdash; 
<a href="index_classes.html">Classes</a> &mdash; 
<a href="index_tables.html">Tables</a>
<hr>
$htmlBody
</body>
</html>
EOD

    close(HTML);
}

sub cleanup()
{
}

